# 위상 정렬

## 목차

<table>
<thead>
  <tr>
    <th>번호</th>
    <th>레벨</th>
    <th>문제</th>
    <th>해설</th>
    <th>코드</th>
  </tr>
</thead>
<tbody>
  <!-- 문제번호 순으로 정렬한다. -->
  <!--
  <tr>
    <td>번호</td>
    <td>레벨</td>
    <td><a href="문제링크">문제제목</a></td>
    <td><a href="해설링크">알고리즘분류</a></td>
    <td><a href="코드링크">C++</a></td>
  </tr>
  -->
  <tr>
    <td>1005</td>
    <td>골드 Ⅲ</td>
    <td><a href="https://www.acmicpc.net/problem/1005">ACM Craft</a></td>
    <td><a href="#boj1005">위상정렬</td>
    <td><a href="boj1005.cpp">C++</a></td>
  </tr>
</tbody>
</table>

<br>

## <a id="boj1005">백준 1005번 ACM Craft</a>

[Problem](https://www.acmicpc.net/problem/1005) / [Solution](boj1005.cpp)

### 문제 요약

- 건설 규칙: 어떤 건물을 지으려면 그 건물을 짓기 전에 지어야 하는 건물을 모두 지어야 한다.
- 건설 시간: 모든 건물은 건설을 시작하여 완료할 때까지 딜레이가 존재한다.
- 건설 순서: 건설 순서(X → Y)는 모든 건물이 건설 가능하도록 주어진다.

건설 규칙에 따라 건물 W를 지을 때까지 걸리는 최소 시간을 구합니다.

### 입력 조건

- 테스트 케이스의 개수 T를 입력받는다.
  - 건물의 개수 N, 건설 순서 규칙의 개수 K를 입력받는다. (2 ≤ N ≤ 1000, 1 ≤ K ≤ 100000)
  - N줄에 걸쳐 공백으로 구분된 건물당 건설 시간 D를 입력받는다. (0 ≤ D ≤ 100000, D는 정수)
  - K줄에 걸쳐 공백으로 구분된 건설 순서 X, Y를 입력받는다. (1 ≤ X, Y ≤ N)
  - 건설해야 할 건물의 번호 W를 입력받는다. (1 ≤ W ≤ N)

### 문제 풀이

위상 정렬은 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 정렬하는 알고리즘입니다. 어떤 건물을 지으려면 그 건물을 짓기 전에 지어야 하는 건물을 모두 지어야 하므로 위상 정렬 알고리즘을 구현해야 합니다.

건물 W를 지을 때까지 걸리는 최소 시간은 어떻게 구할까요? 건물 W를 짓기 전에 지어야 하는 모든 건물이 다 지어질 때까지 걸리는 최소 시간에 건물 W 건설 시간을 더하면 됩니다. 건물 W를 짓기 전에 지어야 하는 건물이 A와 B가 있다고 가정합시다. 건물 W를 지을 때까지 걸리는 최소 시간을 dp[W], 건물 A를 지을 때까지 걸리는 최소 시간을 dp[A], 건물 B를 지을 때까지 걸리는 최소 시간을 dp[B]라고 합시다. 건물 W 건설 시간을 d[W]라고 했을 때, dp[W] = max(dp[A] + d[W], dp[B] + d[W])라고 나타낼 수 있습니다.

'최소'라는 단어에 꽂히면 max 함수를 왜 사용하는지 쉽게 이해되지 않을 수도 있습니다. 하지만 잘 생각해 보세요. **건물 W를 짓기 전에 반드시 건물 A와 건물 B가 둘 다 지어져야 하므로, 건물 A를 지을 때까지 걸리는 최소 시간과 건물 B를 지을 때까지 걸리는 최소 시간이 모두 지난 다음에 건물 W를 짓기 시작할 수 있습니다.** 예를 들어 건물 A를 지을 때까지 걸리는 최소 시간이 10이고, 건물 B를 지을 때까지 걸리는 최소 시간이 20이라고 합시다. 이때 건물 W를 지을 때까지 걸리는 최소 시간 dp[W]는 max(10 + d[W], 20 + d[W])입니다. 시간이 최소 20만큼은 지나야 건물 B가 완성되고, 건물 B가 지어져야 건물 W를 짓기 시작할 수 있습니다.

이제 dp[W] = max(dp[A]] + d[W], dp[B] + d[W])라는 식이 이해가 됐으니, 위상 정렬을 수행하는 과정에서 언제 dp[W] 값을 갱신할지 생각해 봅시다. 먼저 위상 정렬 알고리즘을 구현해 봅시다. 위상 정렬 알고리즘을 구현하는 방법은 간단합니다.

1. 진입 차수가 0인 노드를 큐에 삽입한다.
2. 큐에 저장된 노드 X를 하나씩 확인한다.
3. 노드 NX의 진입 차수를 1 감소시킨다.

여기서 노드 NX는 노드 X와 연결된 다음 노드를 의미합니다. 순환하지 않는 방향 그래프에서 위의 과정을 반복하면, 모든 노드를 방향성에 거스르지 않도록 순서대로 방문할 수 있습니다.

문제에 위상 정렬 알고리즘을 적용해 봅시다. 먼저 지어야 할 건물이 존재하지 않는 건물 X를 큐에 삽입합니다. 큐에 저장된 건물 X가 완성되면 지을 수 있을지도 모르는 다음 건물 NX를 하나씩 확인하며 진입 차수를 1 감소시킵니다. 진입 차수를 감소시킨다는 것은 건물 X를 완성했으니 건물 NX를 지을 준비가 되었을지도 모른다는 의미입니다. dp[NX] = max(dp[X] + d[NX], …)가 됩니다. 그래서 dp[NX] = max(dp[NX], dp[X] + d[NX])라는 식을 사용합니다. 일단 dp[NX]에 dp[X] + d[NX]를 저장해 두고, 만약 건물 NX보다 먼저 지어야 하는 건물 중 건물을 지을 때까지 걸리는 최소 시간이 더 큰 건물이 나왔을 때 dp[NX] = max(dp[NX], dp[X] + d[NX])라는 식으로 값을 갱신할 수 있습니다.

결과적으로 노드 NX의 진입 차수를 1 감소시킬 때마다 dp[NX] 값을 dp[X] + d[NX]로 갱신합니다. 나중에 노드 NX의 진입 차수가 0이 되면 건물 NX보다 먼저 지어야 하는 건물을 모두 확인하게 되고, 여러 건물의 최소 시간 중 가장 큰 최소 시간에 d[NX]를 더한 시간이 dp[NX]에 저장됩니다. 따라서 노드 W의 진입 차수가 0이 되면 dp[W]에는 건물 W를 지을 때까지 걸리는 최소 시간이 저장됩니다.

### 핵심 개념

- 위상 정렬 + 다이나믹 프로그래밍
