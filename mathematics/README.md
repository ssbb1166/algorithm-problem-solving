# 수학

## 목차

### Baekjoon Onilne Judge

<table>
<thead>
  <tr>
    <th>번호</th>
    <th>문제</th>
    <th>해설</th>
    <th>코드</th>
  </tr>
</thead>
<tbody>
  <!-- 문제번호 순으로 정렬한다. -->
  <!--
  <tr>
    <td>번호</td>
    <td><a href="문제링크">문제제목</a></td>
    <td><a href="해설링크">알고리즘분류</a></td>
    <td><a href="코드링크">C++</a></td>
  </tr>
  -->
  <tr>
    <td>1002</td>
    <td><a href="https://www.acmicpc.net/problem/1002">터렛</a></td>
    <td><a href="#boj1002">수학</a></td>
    <td><a href="boj1002.cpp">C++</a></td>
  </tr>
  <tr>
    <td>1004</td>
    <td><a href="https://www.acmicpc.net/problem/1004">어린 왕자</a></td>
    <td><a href="#boj1004">수학</a></td>
    <td><a href="boj1004.cpp">C++</a></td>
  </tr>
  <tr>
    <td>1009</td>
    <td><a href="https://www.acmicpc.net/problem/1009">분산처리</a></td>
    <td><a href="#boj1009">수학</a></td>
    <td><a href="boj1009.cpp">C++</a></td>
  </tr>
</tbody>
</table>

<br>

## <a id="boj1002">백준 1002번 터렛</a>

[Problem](https://www.acmicpc.net/problem/1002) / [Solution](boj1002.cpp)

### 문제 요약

- 조규현 좌표: (x1, y1)
- 백승환 좌표: (x2, y2)
- 조규현과 류재명 사이의 거리: r1
- 백승환과 류재명 사이의 거리: r2

류재명이 있을 수 있는 좌표의 개수를 출력합니다. 좌표의 개수가 무한대일 경우 -1을 출력합니다.

### 입력 조건

- 테스트 케이스의 개수 T를 입력받는다.
  - 공백으로 구분된 정수 x1, y1, r1, x2, y2, r2를 입력받는다.

### 문제 풀이

중심이 (x1, y1)이고 반지름이 r1인 원과 중심이 (x2, y2)이고 반지름이 r2인 원의 교점 개수를 출력하는 문제입니다. 작은 원의 반지름을 r1, 큰 원의 반지름을 r2, 중심 사이의 거리를 dist라 하면 교점 개수는 다음과 같습니다.

- 교점 개수가 무한대일 경우
  - dist = 0, r2 - r1 = 0
- 교점 개수가 2개일 경우
  - r2 - r1 < dist < r1 + r2
- 교점 개수가 1개일 경우
  - dist = r1 + r2 (외접)
  - dist = r2 - r1 (내접)
- 교점 개수가 0개일 경우
  - dist > r1 + r2
  - dist < r2 - r1
  - dist = 0

중심 사이의 거리를 구할 때 제곱근을 계산해야 합니다. 오차가 발생할 수 있으므로 양변을 제곱하여 비교합니다.

```cpp
dist = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)

if (dist == 0 && r1 == r2)
    cout << -1 << '\n';
else if (dist > (r2 - r1) * (r2 - r1) && dist < (r1 + r2) * (r1 + r2))
    cout << 2 << '\n';
else if (dist == (r2 - r1) * (r2 - r1) || dist == (r1 + r2) * (r1 + r2))
    cout << 1 << '\n';
else
    cout << 0 << '\n';
```

### 핵심 개념

- 두 원의 위치 관계에 따른 교점 개수
- 양변을 제곱하여 비교하는 방법

<br>

## <a id="boj1004">백준 1004번 어린 왕자</a>

[Problem](https://www.acmicpc.net/problem/1004) / [Solution](boj1004.cpp)

### 문제 요약

- 출발점: (x1, y1)
- 도착점: (x2, y2)
- 행성계의 중점과 반지름: (cx, cy, r)

n개의 원이 주어집니다. 어린 왕자가 출발점에서 도착점으로 이동할 때 원을 최소 몇 번 지나야 하는지 출력합니다.

### 입력 조건

- 테스트 케이스의 개수 T를 입력받는다.
  - 공백으로 구분된 정수 x1, y1, x2, y2를 입력받는다. (-1000 ≤ x1, y1, x2, y2 ≤ 1000)
  - 행성계의 개수 n을 입력받는다. (1 ≤ n ≤ 50)
    - 공백으로 구분된 정수 cx, cy, r를 입력받는다. (-1000 ≤ cx, cy ≤ 1000, 1 ≤ r ≤ 1000)

### 문제 풀이

원 정보를 입력받을 때마다 해당 원이 출발점과 도착점의 영역을 분리하는지 확인하는 문제입니다. 출발점과 도착점 중 하나만 원 내부에 위치할 경우, 출발점에서 도착점으로 이동하기 위해 반드시 해당 원을 지나야 합니다. 다음은 출발점과 도착점 중 하나만 원 내부에 위치하는지 판단하는 코드입니다.

```cpp
dist1 = (cx - x1) * (cx - x1) + (cy - y1) * (cy - y1);
dist2 = (cx - x2) * (cx - x2) + (cy - y2) * (cy - y2);
if ((dist1 < r * r) ^ (dist2 < r * r)) cnt++;
```

오차가 발생할 수 있으므로 [백준 1002번 터렛](#boj1002) 문제처럼 양변을 제곱하여 비교합니다.

조건문은 `(dist1 < r * r && dist2 > r * r) || (dist1 > r * r && dist2 < r * r)`처럼 작성할 수도 있지만, XOR 연산을 활용하면 `(dist1 < r * r) ^ (dist2 < r * r)`처럼 간단하게 작성할 수 있습니다. 그리고 조건을 만족하면 cnt를 증가시키는 부분은 조건문을 쓰지 않고 `cnt += (dist1 < r * r) ^ (dist2 < r * r)`처럼 작성할 수도 있습니다.

### 핵심 개념

- 원과 점의 위치 관계
- XOR 연산: 둘 중 하나만 참일 경우 참 반환

<br>

## <a id="boj1009">백준 1009번 분산처리</a>

[Problem](https://www.acmicpc.net/problem/1009) / [Solution](boj1009.cpp)

### 문제 요약

- 1번 데이터는 1번 컴퓨터가 처리
- 2번 데이터는 2번 컴퓨터가 처리
- 3번 데이터는 3번 컴퓨터가 처리
- …
- 10번 데이터는 10번 컴퓨터가 처리
- 11번 데이터는 1번 컴퓨터가 처리
- 12번 데이터는 2번 컴퓨터가 처리
- …

1번부터 10번까지 10대의 컴퓨터가 있습니다. a^b번째 데이터가 처리될 컴퓨터의 번호를 출력합니다.

### 입력 조건

- 테스트 케이스의 개수 T를 입력받는다.
  - 공백으로 구분된 정수 a, b를 입력받는다. (1 ≤ a < 100, 1 ≤ b < 1000000)

### 문제 풀이

a^b번째 데이터의 일의 자리를 구하는 문제입니다. 일의 자리가 1이면 1번 컴퓨터, 2이면 2번 컴퓨터, 3이면 3번 컴퓨터가 처리하겠죠. 어떻게 a^b번째 데이터의 일의 자리를 구할 수 있을까요? a를 b번 곱하는 것은 불가능합니다. 숫자가 어마어마하게 커질 테니까요. 어차피 일의 자리만 구하면 되니 a의 일의 자리를 b번 곱하는 건 어떨까요? a의 일의 자리를 b번 곱하는 것도 불가능합니다. a의 일의 자리가 2처럼 작은 숫자라도 b가 큰 수이면 long long 자료형을 써도 결과를 저장할 수 없습니다. 따라서 a의 일의 자리를 곱할 때마다 다시 일의 자리를 구해서 업데이트해 줘야 합니다.

```cpp
int res = 1;
for (int i = 1; i <= b; i++)
    res = (res * a) % 10;
```

더 시간을 줄이기 위해 제곱수의 일의 자리가 규칙적이라는 점을 이용해 보겠습니다.

- 1의 제곱수 일의 자리 규칙: 1, 1, 1, 1, 1, 1, 1, 1, …
- 2의 제곱수 일의 자리 규칙: 2, 4, 8, 6, 2, 4, 8, 6, …
- 3의 제곱수 일의 자리 규칙: 3, 9, 7, 1, 3, 9, 7, 1, …
- 4의 제곱수 일의 자리 규칙: 4, 6, 4, 6, 4, 6, 4, 6, …
- 5의 제곱수 일의 자리 규칙: 5, 5, 5, 5, 5, 5, 5, 5, …
- 6의 제곱수 일의 자리 규칙: 6, 6, 6, 6, 6, 6, 6, 6, …
- 7의 제곱수 일의 자리 규칙: 7, 9, 3, 1, 7, 9, 3, 1, …
- 8의 제곱수 일의 자리 규칙: 8, 4, 2, 6, 8, 4, 2, 6, …
- 9의 제곱수 일의 자리 규칙: 9, 1, 9, 1, 9, 1, 9, 1, …
- 0의 제곱수 일의 자리 규칙: 0, 0, 0, 0, 0, 0, 0, 0, …

모든 숫자에 대해 제곱수의 일의 자리는 똑같은 패턴이 반복됩니다. 패턴이 반복되는 주기를 정리해 봅시다.

- 1의 제곱수 일의 자리 반복 주기: 1
- 2의 제곱수 일의 자리 반복 주기: 4
- 3의 제곱수 일의 자리 반복 주기: 4
- 4의 제곱수 일의 자리 반복 주기: 2
- 5의 제곱수 일의 자리 반복 주기: 1
- 6의 제곱수 일의 자리 반복 주기: 1
- 7의 제곱수 일의 자리 반복 주기: 4
- 8의 제곱수 일의 자리 반복 주기: 4
- 9의 제곱수 일의 자리 반복 주기: 2
- 0의 제곱수 일의 자리 반복 주기: 1

즉, 모든 숫자는 네 번 곱해질 때마다 똑같은 패턴이 등장합니다. 예를 들어 8은 '8, 4, 2, 6'이 반복되고, 9는 '9, 1, 9, 1'이 반복되고, 0은 '0, 0, 0, 0'이 반복됩니다. 이 점을 이용하면 숫자를 b번 곱하지 않고도 바로 일의 자리를 알아낼 수 있습니다.

### 핵심 개념

- 제곱수 일의 자리 규칙
